/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   time.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: donchoi <donchoi@student.42seoul.kr>       +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/01/02 20:41:59 by donchoi           #+#    #+#             */
/*   Updated: 2023/01/02 22:35:34 by donchoi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include<bits/stdc++.h>
using namespace std;

int cnt = 0;
int sCnt = 0;

void solve(int n) {
	sCnt++;
	cout << sCnt << "\n";
	if (n == 0) return;
	// 반복문의 횟수에 따라 시간복잡도의 n^m의 n이 달라짐.
	for (int i = 0; i < 3; i++) {
		solve(n - 1);
	}
}

int go(int n, int m) {
	cnt++;
	if (n == m) return n;
	int mid = (n + m) / 2;
	cout << "mid : " << mid << " ";
	int sum = go(n, mid) + go(mid + 1, m);
	return sum;
}

int main() {
	/**
	 * 시간복잡도
	 * 입력크기에 대해 어떠한 알고리즘이 실행되는데 걸리는 시간, 주요 로직의 반복횟수를 중점적으로 측정됨.
	 * 시간이라는 것은 컴퓨터 사양등 여러가지 요소에 영향을 받음.
	 * 시간복잡도를 설명할 때는 시간이 아니라 어떠한 알고리즘이 주어진 입력크기를 기반으로 어떠한 로직이 몇번 반복되었는가를 중점으로 설명함.
	 * 
	 * Big O 표기법
	 * 복잡도에 영향을 가장 많이 끼치는 항의 상수인자를 빼고 나머지 항을 없애서 복잡도를 나타내는 표기법
	 * 영향이 가장 많은 기준은 입력크기가 증가함에 따라 가장 많이 증가하는 지가 기준임.
	 * 
	 * Big O 표기법의 경우는 보통 외우는게 좋음.
	 * O(n!) > O(2^n) > O(n^2) > O(nlogn) > O(n) > O(logn) > O(1)
	 * 
	 * 상수시간 시간복잡도 => O(1)
	 * 입력 크기와 상관없이 일정한 시간복잡도를 가지는 것을 말함
	 * 다음 예시들은 전부 O(1)의 시간복잡도를 가짐
	 * 
	 * EX)
	 * 입출력: cin, cout, scanf, printf
	 * 사칙연산: +=, -=. *=, /=
	 * 간단한 if문: if(a[2] == 2)
	 * 배열의 인덱스 참조: int a[3] = { 1, 2, 3 };
	*/

	// 문제 1
	// 1/2(n^2 - n)만큼 돌아감.
	// 이 코드의 시간 복잡도는 O(n^2)
	int a = 0;
	int n = 100;
	for (int i = 0; i < n; i++) {
		for (int j = 0; i < j; j++) {
			a += i + j;
		}
	}
	cout << a << "\n";

	// 문제 2
	// n + m만큼 돌아감
	// 이 코드의 시간 복잡도는 O(n + m)
	for (int i = 0; i < 10; i++) {
		cout << i << " ";
	}
	cout << "\n";
	for (int j = 0; j < 10; j++) {
		cout << j << " ";
	}
	cout << "\n";

	// 문제 3
	// n^2 + n + m^2 + m만큼 돌아감
	// 이 코드의 시간 복잡도는 O(n^2 + m^2)
	for (int i = 0; i < 10; i++) {
		cout << "i : " << i << " ";
		for (int j = 0; j < 10; j++) {
			cout << "j : " << j << " ";
		}
		cout << "\n";
	}
	for (int k = 0; k < 10; k++) {
		cout << "k : " << k << " ";
	}
	cout << "\n";

	for (int i = 0; i < 10; i++) {
		cout << "i : " << i << " ";
		for (int j = 0; j < 10; j++) {
			cout << "j : " << j << " ";
		}
		cout << "\n";
	}
	for (int k = 0; k < 10; k++) {
		cout << "k : " << k << " ";
	}
	cout << "\n";

	// 문제 4
	// 2n-1만큼 돌아감
	// 이 코드의 시간복잡도는 O(n)이다.
	// 재귀는 n만큼 반복한다.
	int num = 5;
	int arr[1004];
	for (int i = 0; i < num; i++) {
		arr[i] = i;
	}
	int sum = go(0, num - 1);
	cout << "sum : " << sum << " " << "cnt : " << cnt << "\n";

	// 문제 5
	// 로그(log)는 지수 함수(2^n 같은거)의 역함수이다.
	// 어떤 수를 나타내기 위해 고정된 밑을 몇 번 곱하여야 하는지를 나타냄.
	// log2^X의 경우 2가 밑이다. log2^32 = 5, log2^16 = 4
	// 즉, 2라는 숫자를 X만큼 곱해야 값이 나온다고 함.
	// 고로, log2^n + 1만큼 돌아감
	// 이 코드의 시간복잡도는 O(log2n)이다.
	int aa = 0;
	int ii = 16;
	while (ii > 0) {
		aa += ii;
		ii /= 2;
	}
	cout << aa << "\n";

	// 문제 6
	// 이 문제는 등비수열의 합을 참고해서 풀 수 있는 문제
	// 이 재귀함수에서는 3번의 n만큼 반복한다.
	// 고로, 3n만큼 돌아감.
	// 이런 재귀를 푸는 방법은 main의 횟수 + 재귀의 호출횟수
	// main에서는 O(1)이고 재귀의 호출횟수는 O(3^n)
	// 따라서 이 코드의 3^n의 시간복잡도를 가짐.
	solve(3);
	// 팁: 함수를 얼마나 호출되냐가 n^m의 n을 알게된다.
	// EX) for (int i = 0; i < 3; i++)은 3번 함수를 호출하니깐 3^n이 됨.
	// EX) for (int i = 0; i < 10; i++)은 3번 함수를 호출하니깐 10^n이 됨.

	return 0;
}