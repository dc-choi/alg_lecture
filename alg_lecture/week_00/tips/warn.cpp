/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   warn.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: donchoi <donchoi@student.42seoul.kr>       +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/12/30 17:48:38 by donchoi           #+#    #+#             */
/*   Updated: 2022/12/30 18:12:34 by donchoi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include<bits/stdc++.h>
using namespace std;

// 맞왜틀 팁
int main() {
	/**
	 * 1. bits/stdc++.h에서 기본적으로 사용할 수 없는 변수명
	 * bits/stdc++.h 모든 라이브러리를 로드하기 때문에 다른 라이브러리에서 전역변수로 쓰고 있는 변수명을 사용하지 못함.
	 * 따라서 해당 변수명 같은 경우 그럴 경우에는 define을 써주어야 함.
	 * define을 걸어서 다른 임의의 문자열로 바꾸어 버린다음 다음 코드처럼 구축
	 * 대표적으로 쓰지 못하는 변수명은 다음과 같음
	*/
	#define y1 xoxoxoxo
	#define time xoxoxoxo
	#define prev xoxoxoxo
	#define next xoxoxoxo
	/**
	 * 또한, 보통 함수로 사용되는 이름이나 매개변수로 들어가는 이터레이터의 이름등은
	 * define을 걸어도 쓰지 못함. 즉, 해당 부분은 변수명으로 선언하면 안됨.
	 * EX) vector를 사용할 때 사용하는 end의 경우 define을 걸면 오류 발생
	*/

	/**
	 * 2. 입출력 싱크
	 * 아래 코드는 입출력 싱크를 맞추는 것을 해제한다는 의미입니다.
	 * C++에서 대표적인 입출력 함수는 cin, cout, scanf, printf가 있고
	 * 이는 시스템콜관련 함수이므로 같이 쓰일 때는 입출력싱크를 맞춰줘야 함.
	 * 
	 * 보통 cin, cout과 scanf, printf 중 scanf, printf가 빠름.
	 * 왜냐면 cin, cout은 c라이브러리인 stdio의 버퍼와 동기화하느라 시간을 소비함.
	 * 
	 * cin, cout의 시간을 빠르게 해주는 방법이 있습니다.
	 * 바로 아래코드처럼 싱크를 해제하여 버퍼 동기화를 하지 않는 것이죠.
	 * 하지만 이렇게 했을 때 반드시!! cin, cout를 쓸 때 scanf, printf를 쓰지 말아야 합니다.
	 * 동기가 풀리니 모르는 사이드 이펙트가 발생할 수도 있음.
	*/
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	/**
	 * 3. 스택오버플로우
	 * stack overflow는 함수의 호출이 무한히 반복되면 발생합니다.
	 * 함수가 무한적으로 호출하나 확인을 해야 함.
	 * 함수는 스택에 쌓이면서 실행됨.
	 * 스택의 모든 공간을 다 차지하고 난 후 더 이상의 여유 공간이 없을 때
	 * 또 다시 스택 프레임을 저장하게 되면, 해당 데이터는 스택 영역을 넘어가서 저장되며 에러가 발생됨.
	*/

	/**
	 * 4. 변수 초기화 문제
	 * 항상 변수가 초기화 되어있나 확인을 해야 함.
	 * 문제에서 테스트 케이스가 주어지고 주어진 테스트 케이스당... 하는 문제가 있음.
	 * 그럴 경우 보통 다음과 같은 코드 그리고 while 루프 안에서 로직이 이어지는데
	 * 이 안에서 변수 초기화가 잘 되었는지 항상 확인해야 함.
	*/

	/**
	 * 5. 실수형 연산
	 * 부동소수점 소수표현은 언제나 제한된 정확도를 가지게 됨.
	 * 부동 소수점 값들이 정확한 값이 아니기 때문임.
	 * 따라서 == 등의 연산을 사용하는 것은 거의 불가능함.
	 * 그래서 되도록이면 실수형연산을 자제하는게 좋음.
	*/

	/**
	 * 6. 문자열 크기 선언
	 * 100개짜리 문자를 입력받고 string이 아닌 char[]로 한다면 char[101]로 선언해야 함.
	 * C, C++에서는 문자는 null로 종료되는 것이 원칙이라 마지막에 무조건 \0이 들어감
	*/
	char[100] str; // NO!!
	char[101] str2; // GOOD!!!!!!

	/**
	 * 7. 참조 에러
	 * queue나 stack에서 top이나 pop 연산을 할 때 항상 size를 체크해야 함.
	 * 만약 해당 자료구조에 아무것도 없는데 해달 자료구조의 요소를 참조하려고 하는 경우 오류가 발생함.
	 * 아래 코드처럼 구축해야 합니다.
	 * 
	 * UB
	 * 배열 인덱스 밖으로 벗어난 곳을 참조하는 경우가 대표적이며 예상치 못한 결과 나타났을때 UB(Undefined Behavior)가 발생했다고 함.
	*/
	// if (q.size() && q.top == val)

	/**
	 * 8. endl보다는 "\n"를 사용하기
	 * 속도측면에서는 endl보다는 "\n"를 사용하는게 좋음.
	 * endl은 "\n" + buffer flush라고 생각하면 됨. 출력 싱크를 보다 정확하게 만들어 줌. 
	 * 
	 * 여기서 buffer flush란?
	 * 임시 저장 영역에서 컴퓨터의 영구 메모리로 데이터를 전송하는 것
	 * 파일을 변경하면 한 컴퓨터 화면에서 볼 수 있는 변경사항이 일시적으로 버퍼에 저장되고
	 * 사용자의 작업에 의해 하드디스크라는 영구저장소로 플러시될지, 소멸될지가 정해짐.
	 * 
	 * "\n"의 경우 1, 2, 3, 4, 5가 순차적으로 나오는게 아닌, 한번에 출력될 수 있음.
	 * 즉, flush는 순차적으로 나오도록 해주는 용도임.
	 * 
	 * 코딩테스트에서는 이러한 출력의 정확한 시간적 차이는 중요하지 않음.
	 * 그래서 "\n"만 사용하는게 좋음.
	*/

	return 0;
}