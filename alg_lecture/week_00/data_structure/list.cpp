/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   list.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: donchoi <donchoi@student.42seoul.kr>       +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/12/23 18:29:14 by donchoi           #+#    #+#             */
/*   Updated: 2022/12/23 20:46:01 by donchoi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include<bits/stdc++.h>
using namespace std;

void print(list<int> list) {
	for (auto item : list) cout << item << " ";
	cout << "\n";
}

int main() {
	/**
	 * 연결리스트
	 * 요소가 인접한 메모리 위치에 저장되지 않는 선형 데이터 구조
	 * 요소들은 next, prev라는 포인터로 연결됨
	 * 중복을 허용함.
	 * 
	 * 데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화 시킨 자료구조
	 * 삽입과 삭제가 O(1)이 걸리며 k번째 요소를 참조한다 했을 때 O(k)가 걸림
	 * 
	 * 단일연결리스트
	 * next 포인터밖에 존재하지 않음.
	 * 한 방향으로만 데이터가 연결됨.
	 * 
	 * 이중연결리스트
	 * prev, next, 두개의 포인터로 양방향으로 데이터가 연결됨.
	 * 
	 * 원형연결리스트
	 * 마지막 노드와 첫번째 노드가 연결되어 원을 형성
	 * 단일, 이중과 같이 사용될 수 있음.
	*/
	list<int> l;
	for (int i = 1; i <= 3; i++) l.push_back(i); // 리스트의 뒤부터 value 삽입
	for (int i = 1; i <= 3; i++) l.push_front(i); // 리스트의 앞에서부터 value 삽입

	auto it = l.begin();
	it++;
	l.insert(it, 1000); // 메모리위치에 요소를 삽입합니다.
	print(l);

	it = l.begin();
	it++;
	l.erase(it); // 리스트의 위치에 해당하는 요소를 지움
	print(l);

	l.pop_front(); // 첫번째 요소를 지움
	l.pop_back(); // 마지막 요소를 지움
	print(l);

	cout << l.front() << " : " << l.back() << "\n"; // 맨 앞, 맨 뒤 요소를 참조
	l.clear(); // 모든 요소를 지움

	/**
	 * 랜덤 접근
	 * 직접 접근이라고 하며 배열과 같은 순차적인 데이터가 있을 때
	 * 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능입니다.
	 * k번째 요소에 접근할 때 O(1)이 걸림
	 * EX) vector, array
	 * 
	 * 순차적 접근
	 * 데이터를 저장된 순서대로 검색해야 함. k번째 요소에 접근할 때 O(k)이 걸림
	 * EX) list, stack, queue
	 * 
	 * array와 list의 차이점
	 * array는 연속된 메모리 공간에 데이터를 저장하고 list는 연속되지 않는 메모리 공간에 데이터를 저장함.
	 * array는 삽입과 삭제에는 O(n), 참조에는 O(1)이 걸림
	 * list는 삽입과 삭제에는 O(1), 참조에는 O(n)이 걸림
	 * 따라서 삽입과 삭제가 많이 발생하는 건 list, 참조를 많이하는건 array가 좋다.
	*/

	return 0;
}